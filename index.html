<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Load</title>
    <!-- Include stylesheet -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.core.css" rel="stylesheet">
    <!--<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">-->
    <link href="https://cdn.quilljs.com/1.3.6/quill.bubble.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.rawgit.com/necolas/normalize.css/master/normalize.css">


    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">

    <style>
        html {
            height: 100%;
        }

        body {
            margin: 0;
            height: 100%;
            background-color: rgba(250, 250, 250, 0.38);
            /*background-color: rgba(240, 240, 240, 0.38);*/
        }

        /* Tell Quill not to scroll */
        #quill-container {
            height: auto;
            min-height: 100%;
            /*padding: 70px;*/
            max-width: 732px;
            margin: 0px auto;
        }

        #quill-container .ql-editor {
            font-family: Roboto, CustomSerif, Georgia, Cambria, 'Times New Roman', serif;
            font-size: 18px;
            overflow-y: visible;
            color: rgba(0, 0, 0, 0.75);
            line-height: 1.58;
        }

        /* Specify our own scrolling container */
        #scrolling-container {
            height: 100%;
            min-height: 100%;
            overflow-y: auto;
        }

        .ql-editor p {
            padding-bottom: 1.3rem;
        }

        .ql-editor h1 {
            padding-bottom: 2rem;
        }

        .ql-editor h2 {
            padding-bottom: 1.4rem;
        }

        .ql-editor.ql-syntax {
            background-color: rgb(46, 46, 46);
        }
        .empty {
            position: relative;
        }


        panel {

            top: 0;
            left: 55%;
            position: fixed;
            right: 0;
            margin: 46px 0 0 376px;

        }
        button {
            font-family: CustomSansSerif,'Lucida Grande',Arial,sans-serif;
            font-weight: 600;
            font-style: normal;
            font-size: 17px;
            color: #000;
            text-decoration: none;
            border: 2px solid #333;
            border-radius: 16px;
            padding: 4px 12px;
            margin: 0 0 15px;
            background-color: #fff;
            cursor: pointer;
        }
        .menu-buttons li {
            list-style-type: none;
        }
    </style>
</head>
<body>
<form>
    <div id="scrolling-container">
        <div id="quill-container">
            <h1 class="empty">Тестирование производительности</h1>
            <p>Термин <em>нагрузочное тестирование</em> может быть использован в различных значениях в
                профессиональной
                среде тестирования ПО. В общем случае он означает практику моделирования ожидаемого использования
                приложения
                с помощью эмуляции работы нескольких пользователей одновременно. Таким образом, подобное
                тестирование
                больше
                всего подходит для многопользовательских систем, чаще&nbsp;— использующих клиент-серверную
                архитектуру
                (например, веб-серверов). Однако и другие типы систем ПО могут быть протестированы подобным
                способом.
                Например, текстовый или графический редактор можно заставить прочесть очень большой документ; а
                финансовый
                пакет&nbsp;— сгенерировать отчёт на основе данных за несколько лет. Наиболее адекватно
                спроектированный
                нагрузочный тест даёт более точные результаты.</p>
            <p>Основная цель нагрузочного тестирования заключается в том, чтобы, создав определённую ожидаемую в
                системе
                нагрузку (например, посредством виртуальных пользователей) и, обычно, использовав идентичное
                программное
                и
                аппаратное обеспечение, наблюдать за показателями производительности системы.</p>
            <p>В идеальном случае в качестве критериев успешности нагрузочного тестирования выступают требования к
                производительности системы, которые формулируются и документируются на стадии разработки
                функциональных
                требований к системе до начала программирования основных архитектурных решений. Однако часто бывает
                так,
                что
                такие требования не были четко сформулированы или не были сформулированы вовсе. В этом случае первое
                нагрузочное тестирование будет являться <em>пробным</em> и основываться на разумных
                предположениях об ожидаемой нагрузке и потреблении аппаратной части ресурсов.</p>
            <p>Одним из оптимальных подходов в использовании нагрузочного тестирования для измерений
                производительности
                системы является тестирование на стадии ранней разработки. Нагрузочное тестирование на первых
                стадиях
                готовности архитектурного решения с целью определить его состоятельность называется
                'proof-of-concept'
                тестированием.</p>
        </div>
    </div>
</form>
<panel>
    <ul class="menu-buttons">
        <li><button id="edit">Редактировать</button></li>
        <li><button id="save">Сохранить</button></li>
        <li><button id="publish">Опубликовать</button></li>
    </ul>
</panel>
<!-- Include the Quill library -->
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

<!-- Initialize Quill editor -->
<script>
    var quill = new Quill('#quill-container', {
        modules: {
            toolbar: [
                ['bold', 'italic'],
                ['link', 'blockquote', 'code-block', 'image'],
                [{list: 'ordered'}, {list: 'bullet'}]
            ]
        },
        scrollingContainer: '#scrolling-container',
        placeholder: 'Compose an epic...',
        theme: 'bubble',
    });
    quill.disable();

    var editButton = document.getElementById("edit");
    var saveButton = document.getElementById("save");
    var publishButton = document.getElementById("publish");

    editButton.hidden = false;
    saveButton.hidden = true;
    publishButton.hidden = true;

    editButton.onclick = function () {
        quill.enable();
        editButton.hidden = true;
        saveButton.hidden = false;
        publishButton.hidden = false;
    };
    saveButton.onclick = function () {
        console.log(quill.container.firstChild.innerHTML)
        location.reload();
    };
    // var form = document.querySelector('form');
    // form.onsubmit = function () {
    //     // Populate hidden form on submit
    //     // var about = document.querySelector('input[name=about]');
    //     // about.value = JSON.stringify(quill.getContents());
    //
    //     //console.log("Submitted", $(form).serialize(), $(form).serializeArray());
    //     console.log(quill.getContents())
    //     // No back end to actually submit to!
    //     //alert('Open the console to see the submit data!')
    //     return false;
    // };
</script>
</body>
</html>